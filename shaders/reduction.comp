#version 430 core
#extension GL_NV_shader_atomic_float : enable

#define SIZE 1024
#define CLUSTERS 5
#define MAX_ITER 20

layout(binding = 0) uniform sampler2D normals;
uniform ivec2 u_texSize;

struct Cluster {
	vec3 cntr;
	int size;
};

layout(std430, binding = 0) buffer destBuffer {
	Cluster clusters[CLUSTERS]; 
} ob;


layout(local_size_x = 32, local_size_y = 32, local_size_y = 1) in;

bool moving = false;
int iterations = 0;

//shared vec3 cache[SIZE];

void main() {
	ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
	vec3 N = texture2D(normals, pos).rgb; // ?? is the texture correct?

	int id = pos.x * pos.y + pos.x;

	int centroidIDX = id % CLUSTERS;
	float myDot = -1;
	
	if(id == 0) {
		moving = false;
		iterations = 0;
	}

	if(id < CLUSTERS) {
		ob.clusters[id].cntr = vec3(1.f, 2.f, 3.f);
		ob.clusters[id].size = 13 + id;
	}

	if(length(N) != 0.f) { 

		while(moving && iterations < MAX_ITER) {
			barrier();
			if(id == 0) {
				moving = false;
				iterations++;
			}
			if(id < CLUSTERS) {
				ob.clusters[id].cntr = vec3(0.f, 0.f, 0.f);
				ob.clusters[id].size = 0;
			}
			atomicAdd(ob.clusters[centroidIDX].cntr.x, N.x); //initialize data, possible reduction if I find out how??
			atomicAdd(ob.clusters[centroidIDX].cntr.y, N.y);
			atomicAdd(ob.clusters[centroidIDX].cntr.z, N.z);
			atomicAdd(ob.clusters[centroidIDX].size, 1);
			if(id < CLUSTERS) {
				ob.clusters[id].cntr /= ob.clusters[id].size;
				ob.clusters[id].cntr = normalize(ob.clusters[id].cntr);
			}

			//#pragma optionNV(unroll all)
			for(int k = 0; k < CLUSTERS; ++k) {
				barrier();
				float d = dot(N, ob.clusters[k].cntr);
				if(d > myDot) {
					myDot = d;
					centroidIDX = k;
					moving = true;
				}
			}
		}
	}
}